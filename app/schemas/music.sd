# Copyright Vespa.ai. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.

# A description of a type of data, how to store and index it, and what to compute over the data elements
#
# See:
#  - https://docs.vespa.ai/en/schemas.html
schema music {

    document music {

        field artist type string {
            indexing: summary | index
        }

        field album type string {
            indexing: summary | index
            index: enable-bm25
        }

        field year type int {
            indexing: summary | attribute
        }

        field text type string {
            indexing: summary | index
            index: enable-bm25
        }

        field category_scores type tensor<float>(cat{}) {
            indexing: summary | attribute
        }

    }

    # Embedding field for semantic search
    # Uses 384-dimensional vectors (matches all-MiniLM-L6-v2 model)
    field text_embedding type tensor<float>(x[384]) {
        indexing: input text | embed | attribute | index
        attribute {
            distance-metric: angular
        }
        index {
            hnsw {
                max-links-per-node: 16
                neighbors-to-explore-at-insert: 200
            }
        }
    }

    fieldset default {
        fields: artist, album, text
    }

    # Rank profiles defines what to compute over the data, and how to use the computation result to order them
    # They can be selected at query time (ranking.profile=[name]), and can be everything from simple handwritten
    # expressions as below to references to large machine-learned models.
    #
    # See
    #  - https://docs.vespa.ai/en/ranking.html
    rank-profile rank_albums inherits default {
        inputs {
            query(user_profile) tensor<float>(cat{})
        }
        first-phase {
            expression: bm25(album) + 0.25 * sum(query(user_profile) * attribute(category_scores))
        }
    }

    # Hybrid rank profile: combines text matching (BM25) with semantic similarity
    rank-profile hybrid inherits default {
        inputs {
            query(query_embedding) tensor<float>(x[384])
        }
        first-phase {
            expression {
                0.5 * bm25(text) +
                0.3 * bm25(album) +
                0.2 * bm25(artist) +
                10 * closeness(field, text_embedding)
            }
        }
    }

    # Semantic-only rank profile: pure vector similarity search
    rank-profile semantic inherits default {
        inputs {
            query(query_embedding) tensor<float>(x[384])
        }
        first-phase {
            expression: closeness(field, text_embedding)
        }
    }

}
